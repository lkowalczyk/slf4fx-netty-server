package pl.bluetrain.slf4fx;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.lang.invoke.MethodHandles;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelException;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Netty-based server for receiving log messages generated by SLF4Fx's client.
 * <p>
 * See the original SLF4Fx suite at https://code.google.com/p/slf4fx/.
 * <p>
 * This is designed to be a drop-in replacement for the original SLF4FxServer
 * although with a few twists you should be aware of.
 * <ul>
 * <li>The {@link setDefaultLocalAddress} method does not accept null argument.
 * <li>The {@link #setCredentials(Map)} method does not accept null argument and
 * it will also reject a map which contains null key or null value.
 * 
 * 
 */
public class SLF4FxServer
{
    @SuppressWarnings("unused")
    private final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
    
    private SocketAddress localAddress = new InetSocketAddress("localhost", 18888);
    private Map<String, String> credentials = new HashMap<>();
    private int sessionTimeout = 60;
    private int workersCount = 1;
    private Map<String, Object> bootstrapOptions = new HashMap<>();
    private String categoryPrefix = "slf4fx";
    
    private ServerBootstrap serverBootstrap;
    private ChannelFactory channelFactory;
    private Channel serverChannel;
    
    /**
     * This constructor works the same as calling:
     * 
     * <pre>
     * SLF4FxServer(new InetSocketAddress("localhost", 18888), new NioServerSocketChannelFactory(),
     *              { "child.tcpNoDelay": true, "child.keepAlive", true }, {});
     * </pre>
     * 
     * (maps in pseudocode).
     */
    
    public SLF4FxServer()
    {
        bootstrapOptions.put("child.tcpNoDelay", true);
        bootstrapOptions.put("child.keepAlive", true);
        bootstrapOptions.put("reuseAddress", true);
    }
    
    public SLF4FxServer(SocketAddress localAddress, Map<String, Object> serverBootstrapOptions,
            Map<String, String> credentials, int workersCount)
    {
        if (localAddress == null)
            throw new NullPointerException("localAddress");
        if (serverBootstrapOptions == null)
            throw new NullPointerException("serverBootstrapOptions");
        setCredentials(credentials);
        
        bootstrapOptions.put("child.tcpNoDelay", true);
        bootstrapOptions.put("child.keepAlive", true);
        
        this.serverBootstrap.setPipelineFactory(new ChannelPipelineFactory()
        {
            @Override
            public ChannelPipeline getPipeline()
                throws Exception
            {
                MessageHandler handler = new MessageHandler(SLF4FxServer.this.categoryPrefix,
                        SLF4FxServer.this.credentials);
                return Channels.pipeline(new MessageFrameDecoder(), handler, new MessageFrameEncoder());
            }
        });
        this.serverBootstrap.setOptions(serverBootstrapOptions);
    }
    
    public void setDefaultLocalAddress(final SocketAddress localAddress)
    {
        if (localAddress == null)
            throw new NullPointerException("localAddress");
        this.localAddress = localAddress;
    }
    
    public SocketAddress getDefaultLocalAddress()
    {
        return localAddress;
    }
    
    public void setWorkersCount(final int workersCount)
    {
        if (workersCount < 1)
            throw new IllegalArgumentException("workersCount must be larger than 0 (" + workersCount + ")");
        this.workersCount = workersCount;
    }
    
    public int getWorkersCount()
    {
        return workersCount;
    }
    
    /**
     * Sets accepted credentials consisting of applicationId-secret pairs
     * neither of which may be null. Default credentials are empty which means
     * all logging is accepted.
     * 
     * @param credentials
     *            applicationId-secret pairs neither of which may be null.
     */
    public void setCredentials(Map<String, String> credentials)
    {
        if (credentials == null)
            throw new NullPointerException("credentials");
        for (Map.Entry<String, String> entry : credentials.entrySet())
        {
            if (entry.getKey() == null || entry.getValue() == null)
                throw new IllegalArgumentException("Each credential must have a non-null applicationId and secret");
        }
        this.credentials = new HashMap<>(credentials);
    }
    
    public Map<String, String> getCredentials()
    {
        return Collections.unmodifiableMap(credentials);
    }
    
    public void setSessionTimeout(final int sessionTimeout)
    {
        this.sessionTimeout = sessionTimeout;
    }
    
    public int getSessionTimeout()
    {
        return sessionTimeout;
    }
    
    public void setFlexPolicyResponse(final File file)
        throws IOException
    {
        try (Reader reader = new FileReader(file))
        {
            StringBuilder sb = new StringBuilder();
            char[] buffer = new char[4096];
            int size;
            while ((size = reader.read(buffer)) != -1)
            {
                sb.append(buffer, 0, size);
            }
            setFlexPolicyResponse(sb.toString());
        }
    }
    
    public void setFlexPolicyResponse(final String flexPolicyResponse)
    {
    }
    
    public String getFlexPolicyResponse()
    {
        return null;
    }
    
    public void setReaderBufferSize(final int readerBufferSize)
    {
    }
    
    public int getReaderBufferSize()
    {
        return 1024;
    }
    
    /**
     * Sets category prefix used for all Flash application logging. Default is
     * {@code slf4fx}. Do not include a dot at the end.
     * <p>
     * If null, no prefix apart from the application name is used.
     * 
     * @param prefix
     *            Logging category prefix without the following dot.
     */
    public void setCategoryPrefix(String prefix)
    {
        this.categoryPrefix = prefix;
    }
    
    public String getCategoryPrefix()
    {
        return categoryPrefix;
    }
    
    /**
     * Starts this SLF4FxServer. An instance cannot be started more than once.
     * Second and subsequent invocations of this method will throw
     * IllegalStateException.
     * 
     * @throws ChannelException
     *             if failed to create a new channel and bind it to the local
     *             address.
     * @throws IllegalStateException
     *             if this method is called again without an intervening
     *             {@link #stop()}.
     */
    public synchronized void start()
    {
        if (serverBootstrap != null)
        {
            throw new IllegalStateException("This server instance was already started before.");
        }
        channelFactory = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool(), workersCount);
        serverBootstrap = new ServerBootstrap(channelFactory);
        serverBootstrap.setOptions(bootstrapOptions);
        serverBootstrap.setPipelineFactory(new ChannelPipelineFactory()
        {
            @Override
            public ChannelPipeline getPipeline()
                throws Exception
            {
                MessageHandler handler = new MessageHandler(SLF4FxServer.this.categoryPrefix,
                        SLF4FxServer.this.credentials);
                return Channels.pipeline(new MessageFrameDecoder(), handler, new MessageFrameEncoder());
            }
        });
        serverChannel = serverBootstrap.bind(localAddress);
    }
    
    /**
     * Stops the SLF4Fx server. This method catches and ignores
     * InterruptedException.
     */
    public synchronized void stop()
    {
        try
        {
            stop(true);
        }
        catch (InterruptedException e)
        {
        }
    }
    
    /**
     * Stops the SLF4Fx server. Calling this method before {@link #start()} has
     * no effect, as well as calling it again.
     * 
     * @param uninterruptibly
     *            true if InterruptedException should be ignored.
     */
    public synchronized void stop(boolean uninterruptibly)
        throws InterruptedException
    {
        if (serverChannel != null)
        {
            ChannelFuture future = serverChannel.close();
            if (uninterruptibly)
            {
                future.awaitUninterruptibly();
            }
            else
            {
                future.await();
            }
            channelFactory.releaseExternalResources();
        }
        serverBootstrap = null;
        channelFactory = null;
        serverChannel = null;
    }
}
