package pl.bluetrain.slf4fx;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelException;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Netty-based server for receiving log messages generated by SLF4Fx's client.
 * <p>
 * See the original SLF4Fx suite at https://code.google.com/p/slf4fx/.
 * <p>
 * This is designed to be a drop-in replacement for the original SLF4FxServer
 * although with a few twists you should be aware of.
 * <ul>
 * <li>The {@link setDefaultLocalAddress} method does not accept null argument.
 * <li>The {@link #setCredentials(Map)} method does not accept null argument and
 * it will also reject a map which contains null key or null value.
 * 
 * @author ≈Åukasz Kowalczyk <lukasz@bluetrain.pl>
 */
public class SLF4FxServer
{
    private final Logger log = LoggerFactory.getLogger(SLF4FxServer.class);
    
    private String flexPolicyResponse;
    private SocketAddress localAddress = new InetSocketAddress("localhost", 18888);
    private Map<String, String> credentials = new HashMap<String, String>();
    private int sessionTimeout = 60;
    private int workersCount = 1;
    private Map<String, Object> bootstrapOptions = new HashMap<String, Object>();
    private String categoryPrefix = "slf4fx";
    
    private ServerBootstrap serverBootstrap;
    private ChannelFactory channelFactory;
    private Channel serverChannel;
    
    /**
     * This constructor works the same as calling:
     * 
     * <pre>
     * SLF4FxServer(new InetSocketAddress("localhost", 18888), new NioServerSocketChannelFactory(),
     *              { "child.tcpNoDelay": true, "child.keepAlive", true }, {});
     * </pre>
     * 
     * (maps in pseudocode).
     */
    
    public SLF4FxServer()
    {
        bootstrapOptions.put("child.tcpNoDelay", true);
        bootstrapOptions.put("child.keepAlive", true);
        bootstrapOptions.put("reuseAddress", true);
    }
    
    public SLF4FxServer(SocketAddress localAddress, Map<String, Object> serverBootstrapOptions,
            Map<String, String> credentials, int workersCount)
    {
        if (localAddress == null)
            throw new NullPointerException("localAddress");
        if (serverBootstrapOptions == null)
            throw new NullPointerException("serverBootstrapOptions");
        setCredentials(credentials);
        
        bootstrapOptions.put("child.tcpNoDelay", true);
        bootstrapOptions.put("child.keepAlive", true);
        
        //        this.serverBootstrap.setPipelineFactory(new ChannelPipelineFactory()
        //        {
        //            public ChannelPipeline getPipeline()
        //                throws Exception
        //            {
        //                MessageHandler handler = new MessageHandler(SLF4FxServer.this.categoryPrefix,
        //                        SLF4FxServer.this.credentials);
        //                return Channels.pipeline(new MessageFrameDecoder(), handler, new MessageFrameEncoder());
        //            }
        //        });
        //        this.serverBootstrap.setOptions(serverBootstrapOptions);
    }
    
    public void setDefaultLocalAddress(final SocketAddress localAddress)
    {
        if (localAddress == null)
            throw new NullPointerException("localAddress");
        this.localAddress = localAddress;
    }
    
    public SocketAddress getDefaultLocalAddress()
    {
        return localAddress;
    }
    
    public void setWorkersCount(final int workersCount)
    {
        if (workersCount < 1)
            throw new IllegalArgumentException("workersCount must be larger than 0 (" + workersCount + ")");
        this.workersCount = workersCount;
    }
    
    public int getWorkersCount()
    {
        return workersCount;
    }
    
    /**
     * Sets accepted credentials consisting of applicationId-secret pairs
     * neither of which may be null. Default credentials are empty which means
     * all logging is accepted.
     * 
     * @param credentials
     *            applicationId-secret pairs neither of which may be null.
     */
    public void setCredentials(Map<String, String> credentials)
    {
        if (credentials == null)
            throw new NullPointerException("credentials");
        for (Map.Entry<String, String> entry : credentials.entrySet())
        {
            if (entry.getKey() == null || entry.getValue() == null)
                throw new IllegalArgumentException("Each credential must have a non-null applicationId and secret");
        }
        this.credentials = new HashMap<String, String>(credentials);
    }
    
    public Map<String, String> getCredentials()
    {
        return Collections.unmodifiableMap(credentials);
    }
    
    public void setSessionTimeout(final int sessionTimeout)
    {
        this.sessionTimeout = sessionTimeout;
    }
    
    public int getSessionTimeout()
    {
        return sessionTimeout;
    }
    
    public void setFlexPolicyResponse(final File file)
        throws IOException
    {
        Reader reader = new FileReader(file);
        try
        {
            StringBuilder sb = new StringBuilder();
            char[] buffer = new char[4096];
            int size;
            while ((size = reader.read(buffer)) != -1)
            {
                sb.append(buffer, 0, size);
            }
            setFlexPolicyResponse(sb.toString());
        }
        finally
        {
            try
            {
                reader.close();
            }
            catch (IOException e)
            {
                // ignore
            }
        }
    }
    
    public void setFlexPolicyResponse(final String flexPolicyResponse)
    {
        this.flexPolicyResponse = flexPolicyResponse;
    }
    
    public String getFlexPolicyResponse()
    {
        return flexPolicyResponse;
    }
    
    public void setReaderBufferSize(final int readerBufferSize)
    {
    }
    
    public int getReaderBufferSize()
    {
        return 1024;
    }
    
    /**
     * Sets category prefix used for all Flash application logging. Default is
     * {@code slf4fx}. Do not include a dot at the end.
     * <p>
     * If null, no prefix apart from the application name is used.
     * 
     * @param prefix
     *            Logging category prefix without the following dot.
     */
    public void setCategoryPrefix(String prefix)
    {
        this.categoryPrefix = prefix;
    }
    
    public String getCategoryPrefix()
    {
        return categoryPrefix;
    }
    
    /**
     * Starts this SLF4FxServer. An instance cannot be started more than once.
     * Second and subsequent invocations of this method without an intervening
     * {@link #stop()} will have no effect.
     * 
     * @throws ChannelException
     *             if failed to create a new channel and bind it to the local
     *             address.
     */
    public synchronized void start()
    {
        if (serverBootstrap != null)
        {
            log.warn("This server instance was already started before.");
            return;
        }
        
        final Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put("policy-file-response", flexPolicyResponse);
        
        channelFactory = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool(), workersCount);
        serverBootstrap = new ServerBootstrap(channelFactory);
        serverBootstrap.setOptions(bootstrapOptions);
        serverBootstrap.setPipelineFactory(new ChannelPipelineFactory()
        {
            public ChannelPipeline getPipeline()
                throws Exception
            {
                return Channels.pipeline(
                        new MessageFrameDecoder(),
                        new MessageHandler(SLF4FxServer.this.categoryPrefix, SLF4FxServer.this.credentials,
                                Collections.unmodifiableMap(parameters)), 
                        new MessageFrameEncoder());
            }
        });
        serverChannel = serverBootstrap.bind(localAddress);
    }
    
    /**
     * Stops the SLF4Fx server. This method catches and ignores
     * InterruptedException.
     */
    public synchronized void stop()
    {
        try
        {
            stop(true);
        }
        catch (InterruptedException e)
        {
        }
    }
    
    /**
     * Stops the SLF4Fx server. Calling this method before {@link #start()} has
     * no effect, as well as calling it again.
     * 
     * @param uninterruptibly
     *            true if InterruptedException should be ignored.
     */
    public synchronized void stop(boolean uninterruptibly)
        throws InterruptedException
    {
        if (serverChannel != null)
        {
            ChannelFuture future = serverChannel.close();
            if (uninterruptibly)
            {
                future.awaitUninterruptibly();
            }
            else
            {
                future.await();
            }
            channelFactory.releaseExternalResources();
        }
        serverBootstrap = null;
        channelFactory = null;
        serverChannel = null;
    }
}
