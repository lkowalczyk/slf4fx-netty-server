package io.github.krankenwagen.slf4fx;

import java.lang.invoke.MethodHandles;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelException;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.channel.socket.ServerSocketChannelFactory;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Netty-based server for receiving log messages generated by SLF4Fx's client.
 * <p>
 * This work is heavily based on D. Motylev's SLF4Fx available at
 * https://code.google.com/p/slf4fx/, which originally used Apache Mina as the
 * server framework.
 * 
 */
public class SLF4FxServer
{
    @SuppressWarnings("unused")
    private final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
    private static final SocketAddress DEFAULT_LOCAL_ADDRESS = new InetSocketAddress("localhost", 18888);
    private static final Map<String, Object> DEFAULT_SERVER_BOOTSTRAP_OPTIONS;
    static
    {
        Map<String, Object> options = new HashMap<>();
        options.put("child.tcpNoDelay", true);
        options.put("child.keepAlive", true);
        DEFAULT_SERVER_BOOTSTRAP_OPTIONS = Collections.unmodifiableMap(options);
    }
    
    private final ChannelFactory channelFactory;
    private final SocketAddress localAddress;
    private final ServerBootstrap serverBootstrap;
    
    private String categoryPrefix = "slf4fx";
    private Map<String, String> credentials;
    private Channel serverChannel;
    private boolean started;
    
    /**
     * This constructor works the same as calling (pseudocode regarding maps):
     * 
     * <pre>
     * SLF4FxServer(new InetSocketAddress("localhost", 18888), new NioServerSocketChannelFactory(),
     *              { "child.tcpNoDelay": true, "child.keepAlive", true }, {});
     * </pre>
     */
    public SLF4FxServer()
    {
        this(DEFAULT_LOCAL_ADDRESS, new NioServerSocketChannelFactory(), DEFAULT_SERVER_BOOTSTRAP_OPTIONS, Collections
                .<String, String> emptyMap());
    }
    
    public SLF4FxServer(SocketAddress localAddress, ServerSocketChannelFactory serverSocketChannelFactory)
    {
        this(localAddress, serverSocketChannelFactory, DEFAULT_SERVER_BOOTSTRAP_OPTIONS, Collections
                .<String, String> emptyMap());
    }
    
    public SLF4FxServer(SocketAddress localAddress, int workersCount)
    {
        this(localAddress, new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool(), workersCount), DEFAULT_SERVER_BOOTSTRAP_OPTIONS, Collections
                .<String, String> emptyMap());
    }
    
    public SLF4FxServer(int workersCount)
    {
        this(DEFAULT_LOCAL_ADDRESS, new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool(), workersCount), DEFAULT_SERVER_BOOTSTRAP_OPTIONS, Collections
                .<String, String> emptyMap());
    }
    
    public SLF4FxServer(SocketAddress localAddress, ServerSocketChannelFactory serverSocketChannelFactory,
            Map<String, Object> serverBootstrapOptions, Map<String, String> credentials)
    {
        if (localAddress == null)
            throw new NullPointerException("localAddress");
        if (serverSocketChannelFactory == null)
            throw new NullPointerException("serverSocketChannelFactory");
        if (serverBootstrapOptions == null)
            throw new NullPointerException("serverBootstrapOptions");
        setCredentials(credentials);
        this.localAddress = localAddress;
        this.channelFactory = serverSocketChannelFactory;
        this.serverBootstrap = new ServerBootstrap(channelFactory);
        this.serverBootstrap.setPipelineFactory(new ChannelPipelineFactory()
        {
            @Override
            public ChannelPipeline getPipeline()
                throws Exception
            {
                MessageHandler handler = new MessageHandler(SLF4FxServer.this.categoryPrefix,
                        SLF4FxServer.this.credentials);
                return Channels.pipeline(new MessageFrameDecoder(), handler, new MessageFrameEncoder());
            }
        });
        this.serverBootstrap.setOptions(serverBootstrapOptions);
    }
    
    /**
     * Sets accepted credentials consisting of applicationId-secret pairs
     * neither of which may be null. Default credentials are empty which means
     * all logging is accepted.
     * 
     * @param credentials
     *            applicationId-secret pairs neither of which may be null.
     */
    public void setCredentials(Map<String, String> credentials)
    {
        if (credentials == null)
            throw new NullPointerException("credentials");
        for (Map.Entry<String, String> entry : credentials.entrySet())
        {
            if (entry.getKey() == null || entry.getValue() == null)
                throw new IllegalArgumentException("Each credential must have a non-null applicationId and secret");
        }
        this.credentials = new HashMap<>(credentials);
    }
    
    /**
     * Sets category prefix used for all Flash application logging. Default is
     * 
     * <pre>
     * slf4fx
     * </pre>
     * 
     * . Do not include a dot at the end.
     * <p>
     * If null, no prefix apart from the application name is used.
     * 
     * @param prefix
     *            Logging category prefix without the following dot.
     */
    public void setCategoryPrefix(String prefix)
    {
        this.categoryPrefix = prefix;
    }
    
    /**
     * Starts this SLF4FxServer. An instance cannot be started more than once,
     * regardless of whether it was stopped before attempting to start it again.
     * Second and subsequent invocations of this method will throw
     * IllegalStateException.
     * 
     * @throws ChannelException
     *             if failed to create a new channel and bind it to the local
     *             address.
     */
    public synchronized void start()
    {
        if (started)
        {
            throw new IllegalStateException("This server instance was already started before.");
        }
        started = true;
        serverChannel = serverBootstrap.bind(localAddress);
    }
    
    /**
     * Stops the SLF4Fx server. This method catches and ignores
     * InterruptedException.
     */
    public synchronized void stop()
    {
        try
        {
            stop(true);
        }
        catch (InterruptedException e)
        {
        }
    }
    
    /**
     * Stops the SLF4Fx server. Calling this method before {@link #start()} has
     * no effect, as well as calling it again.
     * 
     * @param uninterruptibly
     *            true if InterruptedException should be ignored.
     */
    public synchronized void stop(boolean uninterruptibly)
        throws InterruptedException
    {
        if (serverChannel != null)
        {
            ChannelFuture future = serverChannel.close();
            if (uninterruptibly)
            {
                future.awaitUninterruptibly();
            }
            else
            {
                future.await();
            }
            channelFactory.releaseExternalResources();
            serverChannel = null;
        }
    }
}
